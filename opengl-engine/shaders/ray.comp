#version 460 core
#extension GL_ARB_gpu_shader_int64 : enable
#extension AMD_gpu_shader_int64 : enable
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;
const float PI = 3.14159265;

#define QUAD 0
#define SPHERE 1
#define MAX_DISTANCE 100000
#define EPS 0.001
uniform mat3 camera_rotation;
uniform vec3 camera_position;

// 1D
uniform isamplerBuffer indicies;
// 3D
uniform samplerBuffer vertices;
uniform samplerBuffer normals;
uniform samplerBuffer texcoords;

// vec3(v1_id, v2_id, v3_id)
uniform isamplerBuffer primatives;

// 4D
//{ vec4(start_prim, num_prims, left, right), vec4(bmin, _), vec4(bmax, _)
uniform samplerBuffer BVH;

uniform float u_time;
struct Ray {
	vec3 origin;
	vec3 dir;
};

struct Material {
	vec3 albedo;
	vec3 reflectivity;
	vec3 emission;
};

struct Plane {
	vec3 pos;
	vec3 normal;
	vec3 right;
	float width;
	float height;
	Material mat;
};

struct Sphere {
	vec3 pos;
	float radius;
	Material mat;
};

struct RayHit {
	vec3 pos;
	vec3 normal;
	Material mat;
};

struct BVHNode {
	int num_prims, start_prim;
	int left, right;
	vec3 bmin, bmax; // bounds
};
const float MAX_DIST = 1000000;
Sphere spheres[100];
int num_spheres = 0;
Plane planes[10];
int num_planes = 0;

Plane light_source;

uint64_t rng_state;

uint64_t rand_pcg()
{
    uint64_t state = rng_state;
    rng_state = rng_state * 747796405u + 2891336453u;
    uint64_t word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float randFloat() {
	return float(rand_pcg() & 0x00ffffffu)/float(0x00ffffffu);
}
/*
gets the normalized device coordinates
maps [0,img_width] -> [-1,1]
and [0, img_height] -> [-1,1]
*/
vec3 getNDC(ivec2 screenCoord, int w, int h) {
	return vec3(float(2*screenCoord.x - w)/w, float(2*screenCoord.y - h)/h, 0.0f);
}

BVHNode getNode(int index) {
	int node_size = 3;
	BVHNode node;
	node.start_prim = int(texelFetch(BVH, index * node_size).x);
	node.num_prims =  int(texelFetch(BVH, index * node_size).y);
	node.left =       int(texelFetch(BVH, index * node_size).z);
	node.right =      int(texelFetch(BVH, index * node_size).w);
	node.bmin =       texelFetch(BVH, index * node_size + 1).xyz; 
	node.bmax =       texelFetch(BVH, index * node_size + 2).xyz; 
	return node;
}

vec3 getVertex(int index) {
	return texelFetch(vertices, index).xyz;
}

bool AABBIntersect(Ray r, vec3 bmin, vec3 bmax, out float t) {
	float tmin, tmax, tymin, tymax, tzmin, tzmax; 
	vec3 bounds[2] = { bmin, bmax };
	vec3 invdir = 1.0f / r.dir;
	ivec3 neg = ivec3(invdir.x < 0, invdir.y < 0, invdir.z < 0);
    tmin = (bounds[neg[0]].x - r.origin.x) * invdir.x; 
    tmax = (bounds[1-neg[0]].x - r.origin.x) * invdir.x;
    tymin = (bounds[neg[1]].y - r.origin.y) * invdir.y;
    tymax = (bounds[1-neg[1]].y - r.origin.y) * invdir.y;
 
    if ((tmin > tymax) || (tymin > tmax)) 
        return false; 
 
    if (tymin > tmin) 
    tmin = tymin; 
    if (tymax < tmax) 
    tmax = tymax; 
 
    tzmin = (bounds[neg[2]].z - r.origin.z) * invdir.z;
    tzmax = (bounds[1-neg[2]].z - r.origin.z) * invdir.z;
 
    if ((tmin > tzmax) || (tzmin > tmax)) 
        return false; 
 
    if (tzmin > tmin) 
		tmin = tzmin; 
    if (tzmax < tmax) 
		tmax = tzmax; 
 
    t = tmin; 
 
    if (t < 0) { 
        t = tmax; 
        if (t < 0) return false; 
    } 
 
    return true; 
}
// primative holds the indicies for the vertices
bool IntersectTri(Ray ray, ivec3 primative, out float t) {
	vec3 dir = ray.dir;
	vec3 orig = ray.origin;
	vec3 v0 = getVertex(primative.x), v1= getVertex(primative.y), v2 = getVertex(primative.z);
	// compute plane's normal
	vec3 v0v1 = v1 - v0;
	vec3 v0v2 = v2 - v0;
	// no need to normalize
	vec3 N = cross(v0v1, v0v2);  //N 
	float area2 = length(N);

	// Step 1: finding P

	// check if ray and plane are parallel ?
	float NdotRayDirection = dot(N, dir);
	if (abs(NdotRayDirection) <= EPS)  //almost 0 
		return false;  //they are parallel so they don't intersect ! 

	// compute d parameter using equation 2
	float d = dot(-N,v0);

	// compute t (equation 3)
	t = -(dot(N, orig) + d) / NdotRayDirection;

	// check if the triangle is in behind the ray
	if (t < 0) return false;  //the triangle is behind 

	// compute the intersection point using equation 1
	vec3 P = orig + t * dir;

	// Step 2: inside-outside test
	vec3 C;  //vector perpendicular to triangle's plane 

	// edge 0
	vec3 edge0 = v1 - v0;
	vec3 vp0 = P - v0;
	C = cross(edge0,vp0);
	if (dot(N,C) < 0) return false;  //P is on the right side 

	// edge 1
	vec3 edge1 = v2 - v1;
	vec3 vp1 = P - v1;
	C = cross(edge1,vp1);
	if (dot(N,C) < 0)  return false;  //P is on the right side 

	// edge 2
	vec3 edge2 = v0 - v2;
	vec3 vp2 = P - v2;
	C = cross(edge2,vp2);
	if (dot(N,C) < 0) return false;  //P is on the right side; 

	return true;  //this ray hits the triangle
}

int BVHIntersect(Ray ray) {
	// TODO implement depth
	float min_dist = -1;
	int node_index = -1;
	int nodes_to_visit[64];
	int current_node = 0;
	nodes_to_visit[0] = current_node;
	while (current_node >= 0) {
		int node_index = nodes_to_visit[current_node];
		current_node--;
		BVHNode node = getNode(node_index);
		float dist;
		if (AABBIntersect(ray, node.bmin, node.bmax, dist)) {
			if (node.num_prims <= 1) {
				int prim_index = texelFetch(indicies, node.start_prim).x;
				ivec3 prim = texelFetch(primatives, prim_index).xyz;
				if (IntersectTri(ray, prim, dist) && dist < min_dist) {
					min_dist = dist;
					node_index = node.start_prim;
				}
			}
			else {
				nodes_to_visit[current_node++] = node.left;
				nodes_to_visit[current_node++] = node.right;
			}
		}
	}
	return node_index;
}


vec3 sampleGeometry(Plane plane, out RayHit hit) {
	float dx = (randFloat() - 0.5) * plane.width/2;
	float dy = (randFloat() - 0.5) * plane.height/2;
	hit.mat = plane.mat;
	hit.normal = plane.normal;
	hit.pos =  plane.pos + plane.right * dx + cross(plane.normal, plane.right) * dy;
	return hit.mat.emission;
}

vec3 randOffset(vec3 vec) {
	float offset = 75;
	float dx = randFloat();
	float dy = randFloat();
	return vec3(vec.x + (dx/offset - dx/(offset*2)), vec.y + (dy/offset-dy/(offset*2)), vec.z);
}
/*

*/
bool rayHitSphere(Ray ray, Sphere sphere, float maxDist, out RayHit info) {
	// math I dervied from eq of a sphere
	float a = dot(ray.dir, ray.dir);
	vec3 sphere_dir = ray.origin - sphere.pos;
	float b = 2*dot(ray.dir, sphere_dir);
	float c = dot(sphere_dir, sphere_dir) - sphere.radius * sphere.radius;
	float disc = b*b - 4*a*c;
	if (disc >= 0) {
		float t = min((-b + sqrt(disc))/(2.0f*a), (-b - sqrt(disc))/(2.0f*a));
		if (t > maxDist || t < 0) return false;
		info.pos = ray.origin + ray.dir * t;
		info.normal = normalize(info.pos - sphere.pos);
		info.mat = sphere.mat;
		return true;
	}
	return false;
}

bool rayHitPlane(Ray ray, Plane plane, float maxDist, out RayHit info) {
	float theta = dot(ray.dir, plane.normal);
	float p = dot(plane.normal, plane.pos - ray.origin);
	vec3 forward = cross(plane.right, plane.normal);
	// the ray is going towards the plane (not away/parallel)
	if (p/theta >= 0 && p/theta <= maxDist) {
		info.pos = ray.origin + ray.dir * (p/theta);
		info.normal = plane.normal;
		info.mat = plane.mat;
		if (dot(ray.dir, plane.normal) > 0) {
			info.mat = Material(vec3(0), vec3(0), vec3(0));
		}
		float width =  abs(dot(forward, plane.pos - info.pos));
		float height = abs(dot(plane.right, plane.pos - info.pos));
		if (width < plane.width/2.0 && height < plane.height/2.0) {
			return true;
		}
	}
	return false;
}

void addPlane(Plane p) {
	planes[num_planes] = p;
	num_planes++;
}
void addSphere(Sphere s) {
	spheres[num_spheres] = s;
	num_spheres++;
}

bool rayHitScene(Ray ray, float maxDist, out RayHit info) {
	float min_dist = MAX_DIST;
	bool hit_something = false;
	for (int i = 0; i < num_spheres; i++) {
		RayHit sphere_info;
		if (rayHitSphere(ray, spheres[i], maxDist, sphere_info)) {
			float dist = length(sphere_info.pos - ray.origin);
			if (dist < min_dist) {
				min_dist = dist;
				info = sphere_info;
				hit_something = true;
			}
		}
	}
	for (int i = 0; i < num_planes; i++) {
		RayHit plane_info;
		if (rayHitPlane(ray, planes[i], maxDist, plane_info)) {
			float dist = length(plane_info.pos - ray.origin);
			if (dist < min_dist) {
				min_dist = dist;
				info = plane_info;
				hit_something = true;
			}
		}
	}
	return hit_something;
}

void addCube(vec3 pos, float w, float l, float h, Material mat, bool cornell) {
	float inv = 1;
	if (cornell) inv *= -1;
	Material red = Material(vec3(1,0,0), vec3(0), vec3(0));
	Material green= Material(vec3(0,1,0), vec3(0), vec3(0));

	Plane[6] ps = {
		{ pos + vec3(w/2,0,0), inv * vec3(1,0,0), vec3(0,1,0), h, l, cornell ? red:mat},
		{ pos + vec3(-w/2,0,0), inv * vec3(-1,0,0), vec3(0,1,0), h, l, cornell ? green:mat},
		{ pos + vec3(0,h/2,0), inv * vec3(0,1,0), vec3(1,0,0), w, l, mat },
		{ pos + vec3(0,-h/2,0), inv * vec3(0,-1,0), vec3(1,0,0), w, l, mat },
		{ pos + vec3(0,0,l/2), inv * vec3(0,0,1), vec3(1,0,0), w, h, mat },
		{ pos + vec3(0,0,-l/2), inv * vec3(0,0,-1), vec3(1,0,0), w, h, mat },
	};

	for (int i = 0; i < 6; i++) {
		if (!(cornell && i == 4)) {
			addPlane(ps[i]);
		}
	}
	
}

vec3 randVectorInHemisphere(vec3 normal) {
	float theta = 2 * PI * randFloat();
    float phi = acos(1 - 2 * randFloat());
    float x = sin(phi) * cos(theta);
    float y = sin(phi) * sin(theta);
    float z = cos(phi);
	vec3 dir = vec3(x,y,z);
	
	return dot(dir, normal) > 0 ? dir:-dir;
}
vec4 trace(Ray ray, vec4 default_color, int bounces) {
	RayHit info;
	Ray view;
	view.origin = ray.origin;
	view.dir = ray.dir;
	vec3 accum = vec3(0);
	vec3 mask = vec3(1);
	float prr = 1; // russian roulette
	for (int i = 0; i < bounces+1; i++) {
		if (!rayHitScene(ray, MAX_DISTANCE, info)) {
			//accum += default_color.rgb * mask;
			break;
		}
		vec3 surface_emission = info.mat.emission;
		if (i == 0) {
			accum += surface_emission * mask;
		};
		// accum += info.mat.emission * mask;
		RayHit light_hit;
		vec3 direct = sampleGeometry(light_source, light_hit);
		vec3 sample_pos = light_hit.pos;
		vec3 surface_pos = info.pos + info.normal * EPS;
		vec3 light_dir = sample_pos - surface_pos;
		float light_dist = length(light_dir) ;
		vec3 light_normal= light_hit.normal;
		vec3 omega = normalize(light_dir);
		if (dot(light_dir, info.normal) < 0 || dot(-light_dir, light_hit.normal) < 0) {
			
		}
		else if (info.mat.emission == 0 && !rayHitScene(Ray(surface_pos, omega), light_dist-EPS, light_hit)) {
			float area = (light_source.width * light_source.height);
			float P = dot(light_normal, -omega) / dot(surface_pos-sample_pos, surface_pos-sample_pos);
			vec3 r = (direct * (info.mat.albedo/PI) * abs(dot(info.normal, light_dir))) * ( P *area);
			accum += r * mask;
		}
		
		//vec3 reflect_dir = normalize(reflect(ray.dir, info.normal));
		vec3 reflect_dir = normalize(randVectorInHemisphere(info.normal));
		ray = Ray(info.pos, reflect_dir);
		
		if (i > 3) {
			prr = max(mask.x, max(mask.y, mask.z));
			prr = max(1, prr);
			if (randFloat() > prr) {
				break;	
			}
			mask *= 1/abs(prr);
		}

		float pdf = 1/(2*PI);
		vec3 brdf = info.mat.albedo / PI; 
		mask *= brdf * dot(reflect_dir, info.normal) / (pdf);
	}
	return vec4(accum,1);
}

RayHit discard_hit;
void main() {
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	vec4 bg_color = vec4(0.1, 0.2, 0.3, 1.0);
	vec4 pixel = bg_color;
	ivec2 dim = imageSize(img_output);
	// set starting seed for random
	rng_state = pixel_coords.x * dim.x * + pixel_coords.y;

	// vec3 ray_origin = getNDC(pixel_coords, dim.x, dim.y);
	vec3 ray_origin = getNDC(pixel_coords, dim.x, dim.y);
	vec3 ray_dir = vec3(ray_origin.xy, -1.0);

	int samples = 4;
	for (int i = 0; i < samples; i++) {
		// pixel += trace(Ray(ray.origin, randOffset(ray.dir)), bg_color, 3);
	}
	pixel /= samples;
	imageStore(img_output, pixel_coords, vec4(texelFetch(indicies, 0))/8.0f);
}